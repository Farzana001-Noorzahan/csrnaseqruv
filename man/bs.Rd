% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/1-bs.R
\name{bs}
\alias{bs}
\title{#' Calculating surrogate variables on top of the existing covariates
#'
#' This function calculates the surrogate variables on top of the
#' existing the covariates that includes just fixed covariates or
#'  both the fix covariates
#' that are not subjected to variable selection and the nuisance
#' covariates that are subjected to variable selection using sva
#' method
#' @param counts a numerical  \code{matrix} of raw counts
#' Counts must be non-negative and NAs are not permitted.
#' @param FixCov a \code{dataframe} of all covariates that
#' are always included in the model, either they are the main
#' factors of interest or the covariates that researchers
#' want to include in the model.
#' @param VarCov a \code{dataframe} of all covariates that
#' are subjected to  selection.
#' @param combine logical. If TRUE (default), combining all FixCov
#' and VarCov, if FALSE, use only FixCov}
\usage{
bs(counts, FixCov, VarCov, print.progress = FALSE)
}
\arguments{
\item{counts}{a numerical  \code{matrix} of raw counts
Counts must be non-negative and NAs are not permitted.}

\item{FixCov}{a \code{data.frame} of the covariates that
are always included in the model.}

\item{VarCov}{a \code{data.frame} of the covariates subjected to  selection.}

\item{print.progress}{logical. If \code{TRUE} the print out the progress of
backward selection.}
}
\value{
A list of 4 components
\item{WorstP5}{a vector of \code{r} value of the eliminated covariates
during the selection process. The first element of the vector is the first
covariate eliminated, and so on.}
\item{VarCov}{it is the same as the input argument.}
\item{FixCov}{it is the same as the input argument.}
}
\description{
#' @return a \code{dataframe} which is the combination of \code{AllCov}
#'and the \code{sva} covariates if there are any.
#' @examples
#' data(counts)
#' data(FixCov)
#' data(VarCov)
#' svacovout <-svacov(counts[1:100,], FixCov, VarCov)
#' dim(svacovout)
#' head(svacovout)
svacov <- function(counts, FixCov, VarCov, combine = FALSE){
  set.seed(1)
  if(combine){
    AllCov <- cbind(FixCov, VarCov)
  }else{
      AllCov <- FixCov
    }
  dm <- stats::model.matrix(stats::formula(paste0("~", paste0(names(AllCov), collapse = "+"))), data = AllCov)
  # dm0 <-stats::model.matrix(stats::formula(paste0("~", paste0(names(FixCov), collapse = "+"))), data = FixCov)
  lib.size = apply(counts, 2, stats::quantile, .75)
  y <- t(log2(t(counts + 0.5)/(lib.size + 1) * 1e+06))
  svaout <- sva::sva(dat = y, mod = dm)
  n.sv <- svaout$n.sv
  if(n.sv ==0){
    sv <- data.frame(dm[,0])
  }else{
    sv  <- data.frame(svaout$sv)
    colnames(sv) <- paste0("sva", 1:ncol(sv))
  }
  VarCov_sva <- cbind(AllCov, sv)
  VarCov_sva
}
Backward Selection Algorithm Using the P-values Ratio Relevance Measurement
}
\details{
This function performs a backward selection algorithm on the set of
available covariates in RNA-seq analysis using the covariate
relevance measurement \code{r} defined as the ratio of the number
of p-values less than 0.05 to a fifth of the number of p-values greater than
.75. It starts with all covariates included in the model, then using \code{\link{limma}{voom}}
to fit the model, calculate $p$-values vector and the relevance measurement
\code{r} for each covariate. It will iteratively removes the covariate
 with smallest \code{r} value.  The process is repeated until
  all covariates are eliminated.
}
\examples{
data(counts)
data(FixCov)
data(VarCov)
bsout <- bs(counts = counts, FixCov, VarCov, print.progress = TRUE)
names(bsout)
bsout$WorstP5
}
